'use client';

import { useSearchParams } from 'next/navigation';
import { Suspense, useState } from 'react';
import { useRouter } from 'next/navigation';
import { MDXRemote } from 'next-mdx-remote/rsc';
import Link from 'next/link';

// Helper to generate slug for linking
function generateSlug(name: string): string {
  return name.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
}

// Define a type for the expected article data structure from the query param
// Adjust based on the actual JSON structure generated by your API
interface GeneratedArticleData {
  title: string;
  date: string;
  thinker: string;
  tags?: string[];
  quote?: string;
  spin?: string;
  // Assuming the generated content is a single string field, e.g., 'analysisContent'
  analysisContent: string; 
  // Add imageUrl and sourceUrl if your generation API includes them
  imageUrl?: string;
  sourceUrl?: string;
}

function PreviewContent() {
  const searchParams = useSearchParams();
  const router = useRouter();
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  // Add null check for searchParams
  if (!searchParams) {
    return <p className="text-center text-gray-500">Laden...</p>; // Or some other loading/error state
  }

  const articleDataString = searchParams.get('articleData');

  if (!articleDataString) {
    return <p className="text-center text-red-500">Error: Geen artikeldata gevonden in de URL.</p>;
  }

  let articleData: GeneratedArticleData | null = null;
  try {
    articleData = JSON.parse(articleDataString);
  } catch (error) {
    console.error("Error parsing article data from query string:", error);
    return <p className="text-center text-red-500">Error: Ongeldige artikeldata ontvangen.</p>;
  }

  if (!articleData) {
    // This case should be caught by the try-catch, but added for robustness
    return <p className="text-center text-red-500">Error: Kon artikeldata niet verwerken.</p>;
  }

  // Destructure for easier access
  const { title, date, thinker, tags, quote, spin, analysisContent, imageUrl, sourceUrl } = articleData;

  // --- Handle Publish --- 
  const handlePublish = async () => {
    setIsLoading(true);
    setError(null);

    try {
        const response = await fetch('/api/publish', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(articleData), // Send the whole data
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.message || `HTTP error! status: ${response.status}`);
        }

        const result = await response.json();
        // Assuming the API returns the slug of the newly created article
        if (result.slug) {
             // Redirect to the new article page on success
             const newArticlePath = `/articles/${result.slug}`;
             router.push(newArticlePath);
             // Optionally show a success message before redirecting, maybe via toast
        } else {
            throw new Error("Publishing succeeded but no slug was returned.");
        }

    } catch (err: any) {
        console.error("Failed to publish article:", err);
        setError(err.message || "An unknown error occurred during publishing.");
    } finally {
        setIsLoading(false);
    }
  };

  // --- Render the preview using similar structure as the final article page --- 
  return (
    <article className="max-w-3xl mx-auto px-4 py-12 md:py-16">
      {/* Re-use breadcrumb logic or a simpler header if needed */}
      {/* <Breadcrumb items={...} /> */}

      {/* Optional Feature Image */}
      {imageUrl && (
          <div className="mb-8 aspect-video relative overflow-hidden rounded-lg">
              {/* Consider using regular img tag here if next/image causes issues in this preview */}
              <img src={imageUrl} alt={title || 'Article feature image'} className="object-cover w-full h-full" />
          </div>
      )}

      {/* Article Header */}
      <header className="mb-8 border-b pb-4">
          <h1 className="text-3xl md:text-4xl font-bold text-gray-900 mb-3">{title}</h1>
          <div className="text-sm text-gray-500 space-y-1 md:space-y-0 md:space-x-2 flex flex-col md:flex-row">
              <span>Gepubliceerd op: {date}</span>
              {thinker && (
                  <>
                      <span className="hidden md:inline">|</span>
                      <span>Denker: {thinker}</span> {/* No link needed in preview? */}
                  </>
              )}
              {tags && tags.length > 0 && (
                  <>
                      <span className="hidden md:inline">|</span>
                      <span>Tags: {tags.join(', ')}</span>
                  </>
              )}
          </div>
          {sourceUrl && (
              <p className="text-sm text-gray-600 mt-4">
                  Bron:&nbsp;
                  <a href={sourceUrl} target="_blank" rel="noopener noreferrer" className="underline hover:text-black">
                      {sourceUrl}
                  </a>
              </p>
          )}
      </header>

      {/* Optional Spin/Quote */}
      {spin && (
          <blockquote className="border-l-4 border-gray-300 pl-4 italic text-gray-700 mb-8">
              {spin}
          </blockquote>
      )}
      {quote && (
          <blockquote className="border-l-4 border-gray-300 pl-4 italic text-gray-500 text-sm mb-8">
              {quote}
          </blockquote>
      )}

      {/* Analysis Block - Use prose styling */}
      <div className="mb-8">
          <h2 className="text-xl font-semibold mb-4">
              Analyse vanuit het perspectief van {thinker}
          </h2>
          {/* Important: Render the actual generated content field (e.g., analysisContent) */}
          {/* If analysisContent is plain text, wrap in <p>. If it's MDX, use MDXRemote */}
          {analysisContent && (
              <div className="prose prose-lg max-w-none">
                  {/* Assuming analysisContent IS Markdown/MDX */} 
                  <MDXRemote source={analysisContent} /> 
                  {/* If it's plain text, use: <p>{analysisContent}</p> */}
              </div>
          )}
      </div>

      {/* Publish Button */}
      <div className="mt-12 border-t pt-6 text-center">
          <button
              onClick={handlePublish}
              disabled={isLoading}
              className="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded shadow-md transition-colors duration-150 disabled:opacity-50 disabled:cursor-not-allowed"
          >
              {isLoading ? 'Bezig met publiceren...' : 'âœ“ Publish Article'}
          </button>
          {/* Display Error Message */}
          {error && (
              <p className="mt-4 text-red-600 text-sm">Error: {error}</p>
          )}
      </div>
    </article>
  );
}

// Main component using Suspense for searchParams
export default function PreviewPage() {
  return (
    // Wrap PreviewContent in Suspense as it uses useSearchParams
    // SiteLayout should be applied in the parent layout (app/layout.tsx or app/generate/layout.tsx if exists)
    <Suspense fallback={<div className="text-center p-10">Laden...</div>}>
      <PreviewContent />
    </Suspense>
  );
} 